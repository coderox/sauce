// This file was GENERATED by command:
//     pump.py apply_variadic.h.pump
// DO NOT EDIT BY HAND!!!

#ifndef SAUCE_INTERNAL_APPLY_VARIADIC_H_
#define SAUCE_INTERNAL_APPLY_VARIADIC_H_

namespace sauce {
namespace internal {

template<typename Parameters, typename Signature>
class ApplyFunction;

template<typename Parameters, typename Signature, typename Passed>
typename ApplyFunction<Parameters, Signature>::Return applyFunction(
  typename ApplyFunction<Parameters, Signature>::Function function, Passed passed) {
  return ApplyFunction<Parameters, Signature>(function).apply(passed);
}

template<typename Parameters, typename Signature, typename Passed>
void observeFunction(typename ApplyFunction<Parameters, Signature>::Function function, Passed passed) {
  ApplyFunction<Parameters, Signature>(function).observe(passed);
}

template<typename Parameters, typename Signature>
class ApplyVoidFunction;

template<typename Parameters, typename Signature, typename Passed>
void applyVoidFunction(typename ApplyVoidFunction<Parameters, Signature>::Function function, Passed passed) {
  (ApplyVoidFunction<Parameters, Signature>(function)).apply(passed);
}

template<typename Parameters, typename Signature>
class ApplyMethod;

template<typename Parameters, typename Signature, typename Passed>
typename ApplyMethod<Parameters, Signature>::Return applyMethod(
  typename ApplyMethod<Parameters, Signature>::Receiver & receiver,
  typename ApplyMethod<Parameters, Signature>::Method method, Passed passed) {
  return ApplyMethod<Parameters, Signature>(method).apply(receiver, passed);
}

template<typename Parameters, typename Signature, typename Passed>
void observeMethod(typename ApplyMethod<Parameters, Signature>::Method method, Passed passed) {
  ApplyMethod<Parameters, Signature>(method).observe(passed);
}

template<typename Parameters, typename Constructed_, typename Allocator_>
class ApplyConstructor {
  typedef Constructed_ (Constructor)();
  typedef typename Allocator_::template rebind<Constructed_>::other Allocator;

  Allocator allocator;

public:

  typedef Constructed_ Constructed;

  ApplyConstructor():
    allocator() {}

  static int arity() {
    return 0;
  }

  template<typename Passed>
  Constructed * apply(Passed) {
    return new(allocator.allocate(1))Constructed();
  }

  template<typename Passed>
  void observe(Passed) {}
};

template<typename Parameters, typename Constructor, typename Allocator, typename Passed>
typename ApplyConstructor<Parameters, Constructor, Allocator>::Constructed * applyConstructor(Passed passed) {
  return ApplyConstructor<Parameters, Constructor, Allocator>().apply(passed);
}

template<typename Parameters, typename Constructor, typename Allocator, typename Passed>
void observeConstructor(Passed passed) {
  ApplyConstructor<Parameters, Constructor, Allocator>().observe(passed);
}

// 0

/* *INDENT-OFF* */
template<typename Parameters, typename Return_>
class ApplyFunction<Parameters, Return_(*)()> {
public:

  typedef Return_ Return;
  typedef Return_ (* Signature)();
  typedef Return_ (* Function)();

private:
  Function function;
public:

  ApplyFunction(Function function):
    function(function) {}

  static int arity() {
    return 0;
  }

  template<typename Passed>
  Return apply(Passed) {

    return function();
  }

  template<typename Passed>
  void observe(Passed) {
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters>
class ApplyVoidFunction<Parameters, void(*)()> {
public:
  typedef void (* Signature)();
  typedef void (* Function)();

private:
  Function function;
public:

  ApplyVoidFunction(Function function):
    function(function) {}

  static int arity() {
    return 0;
  }

  template<typename Passed>
  void apply(Passed) {

    function();
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename Receiver_>
class ApplyMethod<Parameters, Return_(Receiver_::*)()> {
public:
  typedef Return_ Return;
  typedef Receiver_ Receiver;
  typedef Return_ (Receiver_::* Signature)();
  typedef Return_ (Receiver_::* Method)();

private:
  Method method;
public:

  ApplyMethod(Method method):
    method(method) {}

  static int arity() {
    return 0;
  }

  template<typename Passed>
  Return apply(Receiver & receiver, Passed) {

    return (receiver.*method)();
  }

  template<typename Passed>
  void observe(Passed) {
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Allocator_, typename Constructed_>
class ApplyConstructor<Parameters, Constructed_(), Allocator_> {
  typedef Constructed_ (Constructor)();
  typedef typename Allocator_::template rebind<Constructed_>::other Allocator;

  Allocator allocator;

public:

  typedef Constructed_ Constructed;

  ApplyConstructor():
    allocator() {}

  static int arity() {
    return 0;
  }

  template<typename Passed>
  Constructed * apply(Passed) {

    return new(allocator.allocate(1)) Constructed();
  }

  template<typename Passed>
  void observe(Passed) {
  }
};
/* *INDENT-ON* */

// 1

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename A0>
class ApplyFunction<Parameters, Return_(*)(A0)> {
public:

  typedef Return_ Return;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef Return_ (* Signature)(A0);
  typedef Return_ (* Function)(
    typename P0::Type);

private:
  Function function;
public:

  ApplyFunction(Function function):
    function(function) {}

  static int arity() {
    return 1;
  }

  template<typename Passed>
  Return apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));

    return function(a0);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename A0>
class ApplyVoidFunction<Parameters, void(*)(A0)> {
public:
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef void (* Signature)(A0);
  typedef void (* Function)(
    typename P0::Type);

private:
  Function function;
public:

  ApplyVoidFunction(Function function):
    function(function) {}

  static int arity() {
    return 1;
  }

  template<typename Passed>
  void apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));

    function(a0);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename Receiver_, typename A0>
class ApplyMethod<Parameters, Return_(Receiver_::*)(A0)> {
public:
  typedef Return_ Return;
  typedef Receiver_ Receiver;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef Return_ (Receiver_::* Signature)(A0);
  typedef Return_ (Receiver_::* Method)(
    typename P0::Type);

private:
  Method method;
public:

  ApplyMethod(Method method):
    method(method) {}

  static int arity() {
    return 1;
  }

  template<typename Passed>
  Return apply(Receiver & receiver, Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));

    return (receiver.*method)(a0);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Allocator_, typename Constructed_, typename A0>
class ApplyConstructor<Parameters, Constructed_(A0), Allocator_> {
  typedef Constructed_ (Constructor)(A0);
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Allocator_::template rebind<Constructed_>::other Allocator;

  Allocator allocator;

public:

  typedef Constructed_ Constructed;

  ApplyConstructor():
    allocator() {}

  static int arity() {
    return 1;
  }

  template<typename Passed>
  Constructed * apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));

    return new(allocator.allocate(1)) Constructed(a0);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

// 2

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename A0, typename A1>
class ApplyFunction<Parameters, Return_(*)(A0, A1)> {
public:

  typedef Return_ Return;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef Return_ (* Signature)(A0, A1);
  typedef Return_ (* Function)(
    typename P0::Type,
    typename P1::Type);

private:
  Function function;
public:

  ApplyFunction(Function function):
    function(function) {}

  static int arity() {
    return 2;
  }

  template<typename Passed>
  Return apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));

    return function(a0, a1);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename A0, typename A1>
class ApplyVoidFunction<Parameters, void(*)(A0, A1)> {
public:
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef void (* Signature)(A0, A1);
  typedef void (* Function)(
    typename P0::Type,
    typename P1::Type);

private:
  Function function;
public:

  ApplyVoidFunction(Function function):
    function(function) {}

  static int arity() {
    return 2;
  }

  template<typename Passed>
  void apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));

    function(a0, a1);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename Receiver_, typename A0, typename A1>
class ApplyMethod<Parameters, Return_(Receiver_::*)(A0, A1)> {
public:
  typedef Return_ Return;
  typedef Receiver_ Receiver;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef Return_ (Receiver_::* Signature)(A0, A1);
  typedef Return_ (Receiver_::* Method)(
    typename P0::Type,
    typename P1::Type);

private:
  Method method;
public:

  ApplyMethod(Method method):
    method(method) {}

  static int arity() {
    return 2;
  }

  template<typename Passed>
  Return apply(Receiver & receiver, Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));

    return (receiver.*method)(a0, a1);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Allocator_, typename Constructed_, typename A0, typename A1>
class ApplyConstructor<Parameters, Constructed_(A0, A1), Allocator_> {
  typedef Constructed_ (Constructor)(A0, A1);
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Allocator_::template rebind<Constructed_>::other Allocator;

  Allocator allocator;

public:

  typedef Constructed_ Constructed;

  ApplyConstructor():
    allocator() {}

  static int arity() {
    return 2;
  }

  template<typename Passed>
  Constructed * apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));

    return new(allocator.allocate(1)) Constructed(a0, a1);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

// 3

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename A0, typename A1, typename A2>
class ApplyFunction<Parameters, Return_(*)(A0, A1, A2)> {
public:

  typedef Return_ Return;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef Return_ (* Signature)(A0, A1, A2);
  typedef Return_ (* Function)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type);

private:
  Function function;
public:

  ApplyFunction(Function function):
    function(function) {}

  static int arity() {
    return 3;
  }

  template<typename Passed>
  Return apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));

    return function(a0, a1, a2);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename A0, typename A1, typename A2>
class ApplyVoidFunction<Parameters, void(*)(A0, A1, A2)> {
public:
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef void (* Signature)(A0, A1, A2);
  typedef void (* Function)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type);

private:
  Function function;
public:

  ApplyVoidFunction(Function function):
    function(function) {}

  static int arity() {
    return 3;
  }

  template<typename Passed>
  void apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));

    function(a0, a1, a2);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename Receiver_, typename A0, typename A1, typename A2>
class ApplyMethod<Parameters, Return_(Receiver_::*)(A0, A1, A2)> {
public:
  typedef Return_ Return;
  typedef Receiver_ Receiver;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef Return_ (Receiver_::* Signature)(A0, A1, A2);
  typedef Return_ (Receiver_::* Method)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type);

private:
  Method method;
public:

  ApplyMethod(Method method):
    method(method) {}

  static int arity() {
    return 3;
  }

  template<typename Passed>
  Return apply(Receiver & receiver, Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));

    return (receiver.*method)(a0, a1, a2);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Allocator_, typename Constructed_, typename A0, typename A1, typename A2>
class ApplyConstructor<Parameters, Constructed_(A0, A1, A2), Allocator_> {
  typedef Constructed_ (Constructor)(A0, A1, A2);
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Allocator_::template rebind<Constructed_>::other Allocator;

  Allocator allocator;

public:

  typedef Constructed_ Constructed;

  ApplyConstructor():
    allocator() {}

  static int arity() {
    return 3;
  }

  template<typename Passed>
  Constructed * apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));

    return new(allocator.allocate(1)) Constructed(a0, a1, a2);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

// 4

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename A0, typename A1, typename A2, typename A3>
class ApplyFunction<Parameters, Return_(*)(A0, A1, A2, A3)> {
public:

  typedef Return_ Return;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef Return_ (* Signature)(A0, A1, A2, A3);
  typedef Return_ (* Function)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type);

private:
  Function function;
public:

  ApplyFunction(Function function):
    function(function) {}

  static int arity() {
    return 4;
  }

  template<typename Passed>
  Return apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));

    return function(a0, a1, a2, a3);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename A0, typename A1, typename A2, typename A3>
class ApplyVoidFunction<Parameters, void(*)(A0, A1, A2, A3)> {
public:
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef void (* Signature)(A0, A1, A2, A3);
  typedef void (* Function)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type);

private:
  Function function;
public:

  ApplyVoidFunction(Function function):
    function(function) {}

  static int arity() {
    return 4;
  }

  template<typename Passed>
  void apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));

    function(a0, a1, a2, a3);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename Receiver_, typename A0, typename A1, typename A2, typename A3>
class ApplyMethod<Parameters, Return_(Receiver_::*)(A0, A1, A2, A3)> {
public:
  typedef Return_ Return;
  typedef Receiver_ Receiver;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef Return_ (Receiver_::* Signature)(A0, A1, A2, A3);
  typedef Return_ (Receiver_::* Method)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type);

private:
  Method method;
public:

  ApplyMethod(Method method):
    method(method) {}

  static int arity() {
    return 4;
  }

  template<typename Passed>
  Return apply(Receiver & receiver, Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));

    return (receiver.*method)(a0, a1, a2, a3);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Allocator_, typename Constructed_, typename A0, typename A1, typename A2,
    typename A3>
class ApplyConstructor<Parameters, Constructed_(A0, A1, A2, A3), Allocator_> {
  typedef Constructed_ (Constructor)(A0, A1, A2, A3);
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Allocator_::template rebind<Constructed_>::other Allocator;

  Allocator allocator;

public:

  typedef Constructed_ Constructed;

  ApplyConstructor():
    allocator() {}

  static int arity() {
    return 4;
  }

  template<typename Passed>
  Constructed * apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));

    return new(allocator.allocate(1)) Constructed(a0, a1, a2, a3);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

// 5

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename A0, typename A1, typename A2, typename A3, typename A4>
class ApplyFunction<Parameters, Return_(*)(A0, A1, A2, A3, A4)> {
public:

  typedef Return_ Return;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef Return_ (* Signature)(A0, A1, A2, A3, A4);
  typedef Return_ (* Function)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type);

private:
  Function function;
public:

  ApplyFunction(Function function):
    function(function) {}

  static int arity() {
    return 5;
  }

  template<typename Passed>
  Return apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));

    return function(a0, a1, a2, a3, a4);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename A0, typename A1, typename A2, typename A3, typename A4>
class ApplyVoidFunction<Parameters, void(*)(A0, A1, A2, A3, A4)> {
public:
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef void (* Signature)(A0, A1, A2, A3, A4);
  typedef void (* Function)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type);

private:
  Function function;
public:

  ApplyVoidFunction(Function function):
    function(function) {}

  static int arity() {
    return 5;
  }

  template<typename Passed>
  void apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));

    function(a0, a1, a2, a3, a4);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename Receiver_, typename A0, typename A1, typename A2, typename A3,
    typename A4>
class ApplyMethod<Parameters, Return_(Receiver_::*)(A0, A1, A2, A3, A4)> {
public:
  typedef Return_ Return;
  typedef Receiver_ Receiver;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef Return_ (Receiver_::* Signature)(A0, A1, A2, A3, A4);
  typedef Return_ (Receiver_::* Method)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type);

private:
  Method method;
public:

  ApplyMethod(Method method):
    method(method) {}

  static int arity() {
    return 5;
  }

  template<typename Passed>
  Return apply(Receiver & receiver, Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));

    return (receiver.*method)(a0, a1, a2, a3, a4);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Allocator_, typename Constructed_, typename A0, typename A1, typename A2,
    typename A3, typename A4>
class ApplyConstructor<Parameters, Constructed_(A0, A1, A2, A3, A4), Allocator_> {
  typedef Constructed_ (Constructor)(A0, A1, A2, A3, A4);
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Allocator_::template rebind<Constructed_>::other Allocator;

  Allocator allocator;

public:

  typedef Constructed_ Constructed;

  ApplyConstructor():
    allocator() {}

  static int arity() {
    return 5;
  }

  template<typename Passed>
  Constructed * apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));

    return new(allocator.allocate(1)) Constructed(a0, a1, a2, a3, a4);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

// 6

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename A0, typename A1, typename A2, typename A3, typename A4,
    typename A5>
class ApplyFunction<Parameters, Return_(*)(A0, A1, A2, A3, A4, A5)> {
public:

  typedef Return_ Return;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef Return_ (* Signature)(A0, A1, A2, A3, A4, A5);
  typedef Return_ (* Function)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type,
    typename P5::Type);

private:
  Function function;
public:

  ApplyFunction(Function function):
    function(function) {}

  static int arity() {
    return 6;
  }

  template<typename Passed>
  Return apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));

    return function(a0, a1, a2, a3, a4, a5);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
    P5().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
class ApplyVoidFunction<Parameters, void(*)(A0, A1, A2, A3, A4, A5)> {
public:
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef void (* Signature)(A0, A1, A2, A3, A4, A5);
  typedef void (* Function)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type,
    typename P5::Type);

private:
  Function function;
public:

  ApplyVoidFunction(Function function):
    function(function) {}

  static int arity() {
    return 6;
  }

  template<typename Passed>
  void apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));

    function(a0, a1, a2, a3, a4, a5);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename Receiver_, typename A0, typename A1, typename A2, typename A3,
    typename A4, typename A5>
class ApplyMethod<Parameters, Return_(Receiver_::*)(A0, A1, A2, A3, A4, A5)> {
public:
  typedef Return_ Return;
  typedef Receiver_ Receiver;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef Return_ (Receiver_::* Signature)(A0, A1, A2, A3, A4, A5);
  typedef Return_ (Receiver_::* Method)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type,
    typename P5::Type);

private:
  Method method;
public:

  ApplyMethod(Method method):
    method(method) {}

  static int arity() {
    return 6;
  }

  template<typename Passed>
  Return apply(Receiver & receiver, Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));

    return (receiver.*method)(a0, a1, a2, a3, a4, a5);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
    P5().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Allocator_, typename Constructed_, typename A0, typename A1, typename A2,
    typename A3, typename A4, typename A5>
class ApplyConstructor<Parameters, Constructed_(A0, A1, A2, A3, A4, A5), Allocator_> {
  typedef Constructed_ (Constructor)(A0, A1, A2, A3, A4, A5);
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Allocator_::template rebind<Constructed_>::other Allocator;

  Allocator allocator;

public:

  typedef Constructed_ Constructed;

  ApplyConstructor():
    allocator() {}

  static int arity() {
    return 6;
  }

  template<typename Passed>
  Constructed * apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));

    return new(allocator.allocate(1)) Constructed(a0, a1, a2, a3, a4, a5);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
    P5().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

// 7

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename A0, typename A1, typename A2, typename A3, typename A4,
    typename A5, typename A6>
class ApplyFunction<Parameters, Return_(*)(A0, A1, A2, A3, A4, A5, A6)> {
public:

  typedef Return_ Return;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Parameters::template Parameter<A6, 6> P6;
  typedef Return_ (* Signature)(A0, A1, A2, A3, A4, A5, A6);
  typedef Return_ (* Function)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type,
    typename P5::Type,
    typename P6::Type);

private:
  Function function;
public:

  ApplyFunction(Function function):
    function(function) {}

  static int arity() {
    return 7;
  }

  template<typename Passed>
  Return apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));
    typename P6::Type const & a6(P6().template yield<Passed>(passed));

    return function(a0, a1, a2, a3, a4, a5, a6);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
    P5().template observe<Passed>(passed);
    P6().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
class ApplyVoidFunction<Parameters, void(*)(A0, A1, A2, A3, A4, A5, A6)> {
public:
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Parameters::template Parameter<A6, 6> P6;
  typedef void (* Signature)(A0, A1, A2, A3, A4, A5, A6);
  typedef void (* Function)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type,
    typename P5::Type,
    typename P6::Type);

private:
  Function function;
public:

  ApplyVoidFunction(Function function):
    function(function) {}

  static int arity() {
    return 7;
  }

  template<typename Passed>
  void apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));
    typename P6::Type const & a6(P6().template yield<Passed>(passed));

    function(a0, a1, a2, a3, a4, a5, a6);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename Receiver_, typename A0, typename A1, typename A2, typename A3,
    typename A4, typename A5, typename A6>
class ApplyMethod<Parameters, Return_(Receiver_::*)(A0, A1, A2, A3, A4, A5, A6)> {
public:
  typedef Return_ Return;
  typedef Receiver_ Receiver;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Parameters::template Parameter<A6, 6> P6;
  typedef Return_ (Receiver_::* Signature)(A0, A1, A2, A3, A4, A5, A6);
  typedef Return_ (Receiver_::* Method)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type,
    typename P5::Type,
    typename P6::Type);

private:
  Method method;
public:

  ApplyMethod(Method method):
    method(method) {}

  static int arity() {
    return 7;
  }

  template<typename Passed>
  Return apply(Receiver & receiver, Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));
    typename P6::Type const & a6(P6().template yield<Passed>(passed));

    return (receiver.*method)(a0, a1, a2, a3, a4, a5, a6);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
    P5().template observe<Passed>(passed);
    P6().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Allocator_, typename Constructed_, typename A0, typename A1, typename A2,
    typename A3, typename A4, typename A5, typename A6>
class ApplyConstructor<Parameters, Constructed_(A0, A1, A2, A3, A4, A5, A6), Allocator_> {
  typedef Constructed_ (Constructor)(A0, A1, A2, A3, A4, A5, A6);
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Parameters::template Parameter<A6, 6> P6;
  typedef typename Allocator_::template rebind<Constructed_>::other Allocator;

  Allocator allocator;

public:

  typedef Constructed_ Constructed;

  ApplyConstructor():
    allocator() {}

  static int arity() {
    return 7;
  }

  template<typename Passed>
  Constructed * apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));
    typename P6::Type const & a6(P6().template yield<Passed>(passed));

    return new(allocator.allocate(1)) Constructed(a0, a1, a2, a3, a4, a5, a6);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
    P5().template observe<Passed>(passed);
    P6().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

// 8

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename A0, typename A1, typename A2, typename A3, typename A4,
    typename A5, typename A6, typename A7>
class ApplyFunction<Parameters, Return_(*)(A0, A1, A2, A3, A4, A5, A6, A7)> {
public:

  typedef Return_ Return;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Parameters::template Parameter<A6, 6> P6;
  typedef typename Parameters::template Parameter<A7, 7> P7;
  typedef Return_ (* Signature)(A0, A1, A2, A3, A4, A5, A6, A7);
  typedef Return_ (* Function)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type,
    typename P5::Type,
    typename P6::Type,
    typename P7::Type);

private:
  Function function;
public:

  ApplyFunction(Function function):
    function(function) {}

  static int arity() {
    return 8;
  }

  template<typename Passed>
  Return apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));
    typename P6::Type const & a6(P6().template yield<Passed>(passed));
    typename P7::Type const & a7(P7().template yield<Passed>(passed));

    return function(a0, a1, a2, a3, a4, a5, a6, a7);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
    P5().template observe<Passed>(passed);
    P6().template observe<Passed>(passed);
    P7().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5,
    typename A6, typename A7>
class ApplyVoidFunction<Parameters, void(*)(A0, A1, A2, A3, A4, A5, A6, A7)> {
public:
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Parameters::template Parameter<A6, 6> P6;
  typedef typename Parameters::template Parameter<A7, 7> P7;
  typedef void (* Signature)(A0, A1, A2, A3, A4, A5, A6, A7);
  typedef void (* Function)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type,
    typename P5::Type,
    typename P6::Type,
    typename P7::Type);

private:
  Function function;
public:

  ApplyVoidFunction(Function function):
    function(function) {}

  static int arity() {
    return 8;
  }

  template<typename Passed>
  void apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));
    typename P6::Type const & a6(P6().template yield<Passed>(passed));
    typename P7::Type const & a7(P7().template yield<Passed>(passed));

    function(a0, a1, a2, a3, a4, a5, a6, a7);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename Receiver_, typename A0, typename A1, typename A2, typename A3,
    typename A4, typename A5, typename A6, typename A7>
class ApplyMethod<Parameters, Return_(Receiver_::*)(A0, A1, A2, A3, A4, A5, A6, A7)> {
public:
  typedef Return_ Return;
  typedef Receiver_ Receiver;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Parameters::template Parameter<A6, 6> P6;
  typedef typename Parameters::template Parameter<A7, 7> P7;
  typedef Return_ (Receiver_::* Signature)(A0, A1, A2, A3, A4, A5, A6, A7);
  typedef Return_ (Receiver_::* Method)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type,
    typename P5::Type,
    typename P6::Type,
    typename P7::Type);

private:
  Method method;
public:

  ApplyMethod(Method method):
    method(method) {}

  static int arity() {
    return 8;
  }

  template<typename Passed>
  Return apply(Receiver & receiver, Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));
    typename P6::Type const & a6(P6().template yield<Passed>(passed));
    typename P7::Type const & a7(P7().template yield<Passed>(passed));

    return (receiver.*method)(a0, a1, a2, a3, a4, a5, a6, a7);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
    P5().template observe<Passed>(passed);
    P6().template observe<Passed>(passed);
    P7().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Allocator_, typename Constructed_, typename A0, typename A1, typename A2,
    typename A3, typename A4, typename A5, typename A6, typename A7>
class ApplyConstructor<Parameters, Constructed_(A0, A1, A2, A3, A4, A5, A6, A7), Allocator_> {
  typedef Constructed_ (Constructor)(A0, A1, A2, A3, A4, A5, A6, A7);
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Parameters::template Parameter<A6, 6> P6;
  typedef typename Parameters::template Parameter<A7, 7> P7;
  typedef typename Allocator_::template rebind<Constructed_>::other Allocator;

  Allocator allocator;

public:

  typedef Constructed_ Constructed;

  ApplyConstructor():
    allocator() {}

  static int arity() {
    return 8;
  }

  template<typename Passed>
  Constructed * apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));
    typename P6::Type const & a6(P6().template yield<Passed>(passed));
    typename P7::Type const & a7(P7().template yield<Passed>(passed));

    return new(allocator.allocate(1)) Constructed(a0, a1, a2, a3, a4, a5, a6, a7);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
    P5().template observe<Passed>(passed);
    P6().template observe<Passed>(passed);
    P7().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

// 9

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename A0, typename A1, typename A2, typename A3, typename A4,
    typename A5, typename A6, typename A7, typename A8>
class ApplyFunction<Parameters, Return_(*)(A0, A1, A2, A3, A4, A5, A6, A7, A8)> {
public:

  typedef Return_ Return;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Parameters::template Parameter<A6, 6> P6;
  typedef typename Parameters::template Parameter<A7, 7> P7;
  typedef typename Parameters::template Parameter<A8, 8> P8;
  typedef Return_ (* Signature)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
  typedef Return_ (* Function)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type,
    typename P5::Type,
    typename P6::Type,
    typename P7::Type,
    typename P8::Type);

private:
  Function function;
public:

  ApplyFunction(Function function):
    function(function) {}

  static int arity() {
    return 9;
  }

  template<typename Passed>
  Return apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));
    typename P6::Type const & a6(P6().template yield<Passed>(passed));
    typename P7::Type const & a7(P7().template yield<Passed>(passed));
    typename P8::Type const & a8(P8().template yield<Passed>(passed));

    return function(a0, a1, a2, a3, a4, a5, a6, a7, a8);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
    P5().template observe<Passed>(passed);
    P6().template observe<Passed>(passed);
    P7().template observe<Passed>(passed);
    P8().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5,
    typename A6, typename A7, typename A8>
class ApplyVoidFunction<Parameters, void(*)(A0, A1, A2, A3, A4, A5, A6, A7, A8)> {
public:
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Parameters::template Parameter<A6, 6> P6;
  typedef typename Parameters::template Parameter<A7, 7> P7;
  typedef typename Parameters::template Parameter<A8, 8> P8;
  typedef void (* Signature)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
  typedef void (* Function)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type,
    typename P5::Type,
    typename P6::Type,
    typename P7::Type,
    typename P8::Type);

private:
  Function function;
public:

  ApplyVoidFunction(Function function):
    function(function) {}

  static int arity() {
    return 9;
  }

  template<typename Passed>
  void apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));
    typename P6::Type const & a6(P6().template yield<Passed>(passed));
    typename P7::Type const & a7(P7().template yield<Passed>(passed));
    typename P8::Type const & a8(P8().template yield<Passed>(passed));

    function(a0, a1, a2, a3, a4, a5, a6, a7, a8);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename Receiver_, typename A0, typename A1, typename A2, typename A3,
    typename A4, typename A5, typename A6, typename A7, typename A8>
class ApplyMethod<Parameters, Return_(Receiver_::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8)> {
public:
  typedef Return_ Return;
  typedef Receiver_ Receiver;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Parameters::template Parameter<A6, 6> P6;
  typedef typename Parameters::template Parameter<A7, 7> P7;
  typedef typename Parameters::template Parameter<A8, 8> P8;
  typedef Return_ (Receiver_::* Signature)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
  typedef Return_ (Receiver_::* Method)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type,
    typename P5::Type,
    typename P6::Type,
    typename P7::Type,
    typename P8::Type);

private:
  Method method;
public:

  ApplyMethod(Method method):
    method(method) {}

  static int arity() {
    return 9;
  }

  template<typename Passed>
  Return apply(Receiver & receiver, Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));
    typename P6::Type const & a6(P6().template yield<Passed>(passed));
    typename P7::Type const & a7(P7().template yield<Passed>(passed));
    typename P8::Type const & a8(P8().template yield<Passed>(passed));

    return (receiver.*method)(a0, a1, a2, a3, a4, a5, a6, a7, a8);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
    P5().template observe<Passed>(passed);
    P6().template observe<Passed>(passed);
    P7().template observe<Passed>(passed);
    P8().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Allocator_, typename Constructed_, typename A0, typename A1, typename A2,
    typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
class ApplyConstructor<Parameters, Constructed_(A0, A1, A2, A3, A4, A5, A6, A7, A8), Allocator_> {
  typedef Constructed_ (Constructor)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Parameters::template Parameter<A6, 6> P6;
  typedef typename Parameters::template Parameter<A7, 7> P7;
  typedef typename Parameters::template Parameter<A8, 8> P8;
  typedef typename Allocator_::template rebind<Constructed_>::other Allocator;

  Allocator allocator;

public:

  typedef Constructed_ Constructed;

  ApplyConstructor():
    allocator() {}

  static int arity() {
    return 9;
  }

  template<typename Passed>
  Constructed * apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));
    typename P6::Type const & a6(P6().template yield<Passed>(passed));
    typename P7::Type const & a7(P7().template yield<Passed>(passed));
    typename P8::Type const & a8(P8().template yield<Passed>(passed));

    return new(allocator.allocate(1)) Constructed(a0, a1, a2, a3, a4, a5, a6, a7, a8);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
    P5().template observe<Passed>(passed);
    P6().template observe<Passed>(passed);
    P7().template observe<Passed>(passed);
    P8().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

// 10

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename A0, typename A1, typename A2, typename A3, typename A4,
    typename A5, typename A6, typename A7, typename A8, typename A9>
class ApplyFunction<Parameters, Return_(*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)> {
public:

  typedef Return_ Return;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Parameters::template Parameter<A6, 6> P6;
  typedef typename Parameters::template Parameter<A7, 7> P7;
  typedef typename Parameters::template Parameter<A8, 8> P8;
  typedef typename Parameters::template Parameter<A9, 9> P9;
  typedef Return_ (* Signature)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
  typedef Return_ (* Function)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type,
    typename P5::Type,
    typename P6::Type,
    typename P7::Type,
    typename P8::Type,
    typename P9::Type);

private:
  Function function;
public:

  ApplyFunction(Function function):
    function(function) {}

  static int arity() {
    return 10;
  }

  template<typename Passed>
  Return apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));
    typename P6::Type const & a6(P6().template yield<Passed>(passed));
    typename P7::Type const & a7(P7().template yield<Passed>(passed));
    typename P8::Type const & a8(P8().template yield<Passed>(passed));
    typename P9::Type const & a9(P9().template yield<Passed>(passed));

    return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
    P5().template observe<Passed>(passed);
    P6().template observe<Passed>(passed);
    P7().template observe<Passed>(passed);
    P8().template observe<Passed>(passed);
    P9().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5,
    typename A6, typename A7, typename A8, typename A9>
class ApplyVoidFunction<Parameters, void(*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)> {
public:
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Parameters::template Parameter<A6, 6> P6;
  typedef typename Parameters::template Parameter<A7, 7> P7;
  typedef typename Parameters::template Parameter<A8, 8> P8;
  typedef typename Parameters::template Parameter<A9, 9> P9;
  typedef void (* Signature)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
  typedef void (* Function)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type,
    typename P5::Type,
    typename P6::Type,
    typename P7::Type,
    typename P8::Type,
    typename P9::Type);

private:
  Function function;
public:

  ApplyVoidFunction(Function function):
    function(function) {}

  static int arity() {
    return 10;
  }

  template<typename Passed>
  void apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));
    typename P6::Type const & a6(P6().template yield<Passed>(passed));
    typename P7::Type const & a7(P7().template yield<Passed>(passed));
    typename P8::Type const & a8(P8().template yield<Passed>(passed));
    typename P9::Type const & a9(P9().template yield<Passed>(passed));

    function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Return_, typename Receiver_, typename A0, typename A1, typename A2, typename A3,
    typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
class ApplyMethod<Parameters, Return_(Receiver_::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)> {
public:
  typedef Return_ Return;
  typedef Receiver_ Receiver;
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Parameters::template Parameter<A6, 6> P6;
  typedef typename Parameters::template Parameter<A7, 7> P7;
  typedef typename Parameters::template Parameter<A8, 8> P8;
  typedef typename Parameters::template Parameter<A9, 9> P9;
  typedef Return_ (Receiver_::* Signature)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
  typedef Return_ (Receiver_::* Method)(
    typename P0::Type,
    typename P1::Type,
    typename P2::Type,
    typename P3::Type,
    typename P4::Type,
    typename P5::Type,
    typename P6::Type,
    typename P7::Type,
    typename P8::Type,
    typename P9::Type);

private:
  Method method;
public:

  ApplyMethod(Method method):
    method(method) {}

  static int arity() {
    return 10;
  }

  template<typename Passed>
  Return apply(Receiver & receiver, Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));
    typename P6::Type const & a6(P6().template yield<Passed>(passed));
    typename P7::Type const & a7(P7().template yield<Passed>(passed));
    typename P8::Type const & a8(P8().template yield<Passed>(passed));
    typename P9::Type const & a9(P9().template yield<Passed>(passed));

    return (receiver.*method)(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
    P5().template observe<Passed>(passed);
    P6().template observe<Passed>(passed);
    P7().template observe<Passed>(passed);
    P8().template observe<Passed>(passed);
    P9().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

/* *INDENT-OFF* */
template<typename Parameters, typename Allocator_, typename Constructed_, typename A0, typename A1, typename A2,
    typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
class ApplyConstructor<Parameters, Constructed_(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), Allocator_> {
  typedef Constructed_ (Constructor)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
  typedef typename Parameters::template Parameter<A0, 0> P0;
  typedef typename Parameters::template Parameter<A1, 1> P1;
  typedef typename Parameters::template Parameter<A2, 2> P2;
  typedef typename Parameters::template Parameter<A3, 3> P3;
  typedef typename Parameters::template Parameter<A4, 4> P4;
  typedef typename Parameters::template Parameter<A5, 5> P5;
  typedef typename Parameters::template Parameter<A6, 6> P6;
  typedef typename Parameters::template Parameter<A7, 7> P7;
  typedef typename Parameters::template Parameter<A8, 8> P8;
  typedef typename Parameters::template Parameter<A9, 9> P9;
  typedef typename Allocator_::template rebind<Constructed_>::other Allocator;

  Allocator allocator;

public:

  typedef Constructed_ Constructed;

  ApplyConstructor():
    allocator() {}

  static int arity() {
    return 10;
  }

  template<typename Passed>
  Constructed * apply(Passed passed) {
    typename P0::Type const & a0(P0().template yield<Passed>(passed));
    typename P1::Type const & a1(P1().template yield<Passed>(passed));
    typename P2::Type const & a2(P2().template yield<Passed>(passed));
    typename P3::Type const & a3(P3().template yield<Passed>(passed));
    typename P4::Type const & a4(P4().template yield<Passed>(passed));
    typename P5::Type const & a5(P5().template yield<Passed>(passed));
    typename P6::Type const & a6(P6().template yield<Passed>(passed));
    typename P7::Type const & a7(P7().template yield<Passed>(passed));
    typename P8::Type const & a8(P8().template yield<Passed>(passed));
    typename P9::Type const & a9(P9().template yield<Passed>(passed));

    return new(allocator.allocate(1)) Constructed(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  }

  template<typename Passed>
  void observe(Passed passed) {
    P0().template observe<Passed>(passed);
    P1().template observe<Passed>(passed);
    P2().template observe<Passed>(passed);
    P3().template observe<Passed>(passed);
    P4().template observe<Passed>(passed);
    P5().template observe<Passed>(passed);
    P6().template observe<Passed>(passed);
    P7().template observe<Passed>(passed);
    P8().template observe<Passed>(passed);
    P9().template observe<Passed>(passed);
  }
};
/* *INDENT-ON* */

}

namespace i = ::sauce::internal;

}

#endif // SAUCE_INTERNAL_APPLY_VARIADIC_H_
